<?php

namespace App\Models\Restaurant;

use App\Helpers\Range\TimeRange;
use App\Helpers\Traits\ScheduleResponseTrait;
use App\Models\BaseModel;
use App\Models\Schedule\ScheduleType;
use App\Models\Schedule\Slots;
use App\Models\Schedule\WeekDays;
use Illuminate\Support\Collection;
use \DateTime;
use App\Helpers\Range\DateTime as ExtendedDateTime;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;
use Illuminate\Support\Facades\Log;

/**
 * Working hour schedule
 * Class RestaurantSchedule
 * @package App\Models\Restaurant
 */
class RestaurantSchedule extends BaseModel
{
    use ScheduleResponseTrait;

    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub
        static::addGlobalScope(new class implements Scope
        {
            public function apply(Builder $builder, Model $model)
            {
                return $builder->with('outlet', 'type', 'weekDay');
            }
        });
    }

    protected $table = 'restaurant_schedules';

    protected $fillable = [
        'type',
        'restaurant_id', // relationship with restaurant
        'outlet_id', // If schedule is for outlet
        'location_id', //
        'weekday_id', // monday to sunady
        'type_id', // pickup / delivery
        'specific_date', // specific date to avoid
        'from', // start time
        'to', // end time
        'value', //
        'enabled', // same as active?
        'old_restaurant_id', //
        'old_location_id', //
        'active' // indicates if active
    ];

    private $cache = array(
        'from_date' => null,
        'to_date' => null,
    );

    public function restaurant()
    {
        return $this->belongsTo(Restaurant::class);
    }

    public function outlet()
    {
        return $this->belongsTo(RestaurantOutlets::class, 'outlet_id', 'id');
    }

    public function restaurantLocation()
    {
        return $this->belongsTo(RestaurantLocation::class, 'location_id', 'id');
    }

    public function type()
    {
        return $this->belongsTo(ScheduleType::class, 'type_id', 'id');
    }

    /**
     * Other schedules that that similar to this one, but not this one
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function relatedSchedules()
    {
        return $this->hasMany(RestaurantSchedule::class, 'restaurant_id', 'restaurant_id')
            ->where('weekday_id', $this->weekday_id)
            ->where('type_id', $this->type_id)
            ->where('id', '<>', $this->id);
    }

    /**
     * Checks itself if it has open hours
     */
    public function open()
    {
        return $this->hasOne(RestaurantSchedule::class, 'id', 'id')
            ->where('weekday_id', WeekDays::current()->id)
            ->where(function ($schedule) {
                $now = now();
                $schedule->where('from', '<=', $now->format('H:i:00'))
                    ->where('to', '>=', $now->format('H:i:00'));
            });
    }

    /**
     * Checks self if it has no open schedules
     */
    public function closed()
    {
        return $this->hasOne(RestaurantSchedule::class, 'id', 'id')->where(function ($schedule) {
            $schedule->whereDoesntHave('open');
        });
    }

    /**
     * Each restaurant
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function weekDay()
    {
        return $this->belongsTo(WeekDays::class, 'weekday_id', 'id');
    }

    public function basicResponse()
    {
        return array(
            'ref' => $this->uuid,
            'type' => $this->type()->get(),
            'weekDay' => $this->weekDay ? $this->weekDay->simpleResponse() : null,
            'outlet' => $this->outlet ? $this->outlet->simpleResponse() : null,
            'location' => $this->restaurantLocation ? $this->restaurantLocation->simpleResponse() : null,
        );
    }

    public function getFromDateAttribute(): ExtendedDateTime
    {
        if (null === $this->cache['from_date']) {
            $this->cache['from_date'] = (new ExtendedDateTime($this->from))->setDate(2019, 01, 01);
        } else {
            if ($this->cache['from_date']->format('H:i:s') !== $this->from) {
                $this->cache['from_date'] = (new ExtendedDateTime($this->from))->setDate(2019, 01, 01);
            }
        }
        return $this->cache['from_date'];
        //        return (new ExtendedDateTime($this->from))->setDate(2019, 01, 01);
    }

    public function getToDateAttribute(): ExtendedDateTime
    {
        if (null === $this->cache['to_date']) {
            $this->cache['to_date'] = (new ExtendedDateTime($this->to))->setDate(2019, 01, 01);
        } else {
            if ($this->cache['to_date']->format('H:i:s') !== $this->to) {
                $this->cache['to_date'] = (new ExtendedDateTime($this->to))->setDate(2019, 01, 01);
            }
        }
        return $this->cache['to_date'];
    }

    /**
     * Will check if time range is
     * @param TimeRange $range
     * @return bool
     */
    public function inRange(TimeRange $range): bool
    {
        foreach ($range as $date) {
            if ($date >= $this->from_date && $date <= $this->to_date) {
                return true;
            }
        }
        return false;
    }
    
    public function includes(ExtendedDateTime $time): bool
    {


        if ($this->to_date->time() == "00:00" && $time->from()->time() == "23:45" && $time->to()->time() >= "00:00")
            return !$this->trashed() && $this->from_date->time() <= $time->from()->time() && $this->to_date->time() <= $time->to()->time();

        if ($time->from()->time() == "23:45" && $this->to_date->time() != "23:45")
            return !$this->trashed() && $this->from_date->time() <= $time->from()->time() && $this->to_date->time() < $time->to()->time();
        if ($this->to_date->time() == "00:00" && $time->from()->time() <= "23:45" && $time->to()->time() >= "00:00")
            return !$this->trashed() && $this->from_date->time() <= $time->from()->time() && $this->to_date->time() <= $time->to()->time();



        return !$this->trashed() && $this->from_date->time() <= $time->from()->time() && $this->to_date->time() >= $time->to()->time();
    }

    public function isLower(ExtendedDateTime $time): bool
    {
        return $this->from_date->time() < $time->from()->time();
    }

    public function isUpper(ExtendedDateTime $time): bool
    {
        return $this->to_date->time() > $time->time();
    }

    /**
     * To check if lower slot can be matched. If so, this record can be simply extended
     * @param ExtendedDateTime $slot
     * @return mixed
     */
    public function lowerSlot()
    {
        return (clone $this->from_date)->modify('-15Minutes');
    }

    public function couldBecomeLowerSlot(ExtendedDateTime $slot): bool
    {
        return $slot->to()->time() === $this->lowerSlot()->time();
    }

    public function shrinkLower()
    {
        $this->from = $this->from_date->modify('+15Minutes')->format('H:i:00');
        $this->save();
        if ($this->from >= $this->to && $this->to == '00:00:00') {
        }else if ($this->from >= $this->to) {
            $this->forceDelete();
        }
    }

    /**
     * To check if upper slot can be matched, if so, this record can be simply extended
     * @return ExtendedDateTime
     */
    public function upperSlot(): ExtendedDateTime
    {
        return (clone $this->to_date)->modify('+15Minutes');
    }

    public function couldBecomeUpperSlot(ExtendedDateTime $option): bool
    {
        return $this->upperSlot()->time() === $option->time();
    }

    public function shrinkUpper()
    {
        $this->to = $this->from_date->modify('-15Minutes')->format('H:i:00');
        $this->save();
        if ($this->from >= $this->to) {
            $this->forceDelete();
        }
    }

    public function shrinkUpperNew()
    {
        $this->to = $this->to_date->modify('-15Minutes')->format('H:i:00');
        $this->save();
        if ($this->from >= $this->to) {
            $this->forceDelete();
        }
    }

    /**
     * Creates a duplicate, which has start time that coinsides with given option end time
     * @param ExtendedDateTime $option
     * @return bool
     */
    public function splitInTheMiddle(ExtendedDateTime $option): bool
    {
        if ($this->includes($option)) {
            $duplicate = $this->replicate(['uuid', 'id', 'created_at', 'updated_at', 'deleted_at']);
            $this->to = $option->from()->timeWithSeconds();
            $this->active = 1;
            $this->save();
            $duplicate->from = $option->to()->timeWithSeconds();
            $duplicate->active = 1;
            $duplicate->save();

            // some additional checks
            if($duplicate->to_date->time() == '00:00' && $this->from_date->time() == '00:00'){
                return true;
            }

            if($duplicate->to_date->time() == '00:00' && $duplicate->from_date->time() >= $duplicate->to_date->time()){
                return true;
            }

            if ($duplicate->from_date->time() >= $duplicate->to_date->time()) {
                $duplicate->forceDelete();
            }

            if ($this->from_date->time() >= $this->to_date->time()) {
                $this->forceDelete();
            }
            return true;
        }
        return false;
    }

    public function joinMultiple(ExtendedDateTime $date): bool
    {
        if ($this->to == $date->from()->timeWithSeconds()) {
            //            Log::debug('joinMultiple if');
            $this->to = $date->to()->timeWithSeconds();
            $this->save();
            return true;
        } elseif ($this->from == $date->to()->timeWithSeconds()) {
            //            Log::debug('joinMultiple elseif');
            $this->from = $date->from()->timeWithSeconds();
            $this->save();
            return true;
        } else {
            //            Log::debug('joinMultiple else');
            // have to create new one
            if ($this->to > $date->timeWithSeconds() && $this->from_date < $date->to()) {
                //                Log::debug('joinMultiple else -> if');
                $replica = $this->replicate(['id', 'uuid', 'created_at', 'updated_at', 'deleted_at']);
                $replica->from = $date->from()->timeWithSeconds();
                $replica->to = $date->to()->timeWithSeconds();
                $replica->save();
                return true;
            }
        }

        //        Log::debug('joinMultiple : none');
        return false;
       
    }

    /**
     * Will join multiple schedules into one if it will turn out that 15 minutes is time that separates them
     * @param ExtendedDateTime $time
     * @return bool
     */
    public function joinUsingSlot(ExtendedDateTime $time): bool
    {
        $broaderStart = $this->relatedSchedules->where('to', $time->from()->time())->first();
        $broaderEnd = $this->relatedSchedules->where('from', $time->to()->time())->first();

        if (null !== $broaderEnd || null !== $broaderStart) {
            if (null !== $broaderStart) {
                $this->from = $broaderStart->from;
                $broaderStart->forceDelete();
            }

            if (null !== $broaderEnd) {
                $this->to = $broaderEnd->to;
                $broaderEnd->forceDelete();
            }
            $this->save();
            return true;
        }
        return false;
    }

    public function include(ExtendedDateTime $slot): bool
    {
        Log::debug(__CLASS__ . ' ' . __METHOD__);
        if ($this->couldBecomeLowerSlot($slot)) {
            Log::debug('couldBecomeLowerSlot');
            $this->from = $slot->timeWithSeconds();
            $this->save();
        } elseif ($this->couldBecomeUpperSlot($slot)) {
            Log::debug('couldBecomeUpperSlot');
            $this->to = $slot->timeWithSeconds();
            $this->save();
        } else {
            Log::debug('else');
            return $this->joinMultiple($slot);
        }
        Log::debug('none');
        return false;
    }

    /**
     * Returns boolean to indicate it exclusion was successfull
     * @param ExtendedDateTime $slot
     * @return bool
     */
    public function exclude(ExtendedDateTime $slot): bool
    {
        Log::debug(__CLASS__ . ' ' . __METHOD__);
        if ($this->includes($slot)) {
            Log::debug('includes');
            if ($this->isLower($slot) && $this->isUpper($slot)) {
                //                $this->from = '00:00:00';
                //                $this->to = '00:00:00';
                //                $this->save();

                //$this->forceDelete();
                if($slot->from()->time() == $this->from_date->time() && $slot->to()->time() == $this->to_date->time()){
                $this->forceDelete();}
                if($slot->from()->time() > $this->from_date->time() && $slot->to()->time() < $this->to_date->time()){ //split from middle not for 24 hrs schedule
                $this->splitInTheMiddle($slot);}
                if($slot->from()->time() > $this->from_date->time() && $slot->to()->time() <= $this->to_date->time()){ // split last slot not for 24 hrs schedule
                $this->shrinkUpperNew();}
                if($slot->from()->time() >= $this->from_date->time() && $slot->to()->time() < $this->to_date->time()){
                $this->shrinkLower();}
            } elseif ($this->isLower($slot)) {
                Log::debug('isLower');
                //$this->shrinkLower();
                if($slot->from()->time() != '00:00' && $slot->to()->time() != '00:00'){
                $this->splitInTheMiddle($slot);}
                if($slot->from()->time() != '00:00' && $slot->to()->time() == '00:00'){ // split last slot for 24 hrs schedule
                $this->shrinkUpperNew($slot);}
                if($slot->from()->time() == '00:00' && $slot->to()->time() != '00:00'){
                $this->shrinkUpperNew($slot);}
            } elseif ($this->isUpper($slot)) { //split first slot but not 00:00
                Log::debug('isUpper');
                //$this->shrinkUpper();
                $this->shrinkLower();
            } else {
                Log::debug('splitInTheMiddle');
                if(($slot->from()->time() == $this->from_date->time()) && ($this->to_date->time() == '00:00' || $slot->to()->time() <= $this->to_date->time())){
                    $this->shrinkLower($slot);
                }else if($slot->from()->time() == '00:00' && $slot->to()->time() != '00:00'){ // split first slot for 24 hrs schedule
                    $this->shrinkLower($slot);
                }else
                $this->splitInTheMiddle($slot);
            }
            Log::debug('Will return true');
            return true;
        }
        Log::debug('Will return false');
        return false;
    }

    /**
     * This this was used to test or to seed db at some point
     * @return array
     * @throws \Exception
     */
    public static function semiRandomTimes(): array
    {
        $minutes = [15, 30, 45, 60];
        $startMinutesId = array_rand($minutes);
        $endMinutesId = array_rand($minutes);

        $start = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        $startId = array_rand($start);
        $end = [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
        $endId = array_rand($end);
        return array(
            'from' => (new DateTime())->setTime($start[$startId], $minutes[$startMinutesId]),
            'to' => (new DateTime())->setTime($end[$endId], $minutes[$endMinutesId])
        );
    }

    public function response(ExtendedDateTime $time): array
    {
        $includes = function (ExtendedDateTime $time) {
            return $this->includes($time);
        };
        return $this->genericScheduleResponse($time, $includes, $this->restaurant, $this->outlet, $this->type, $this->weekDay);
        
    }

    /**
     * These are not essential, but they do help to test
     * @param $query
     * @return mixed
     */
    public function scopeDelivery($query)
    {
        return $query->where('type_id', ScheduleType::delivery()->id);
    }

    public function scopePickup($query)
    {
        return $query->where('type_id', ScheduleType::pickup()->id);
    }

    protected function scopeDay($query, WeekDays $day)
    {
        return $query->where('weekday_id', $day->id);
    }

    public function scopeMonday($query)
    {
        return $this->scopeDay($query, WeekDays::monday());
    }

    public function scopeTuesday($query)
    {
        return $this->scopeDay($query, WeekDays::tuesday());
    }

    public function scopeWednesday($query)
    {
        return $this->scopeDay($query, WeekDays::wednesday());
    }

    public function scopeThursday($query)
    {
        return $this->scopeDay($query, WeekDays::thursday());
    }

    public function scopeFriday($query)
    {
        return $this->scopeDay($query, WeekDays::friday());
    }

    public function scopeSaturday($query)
    {
        return $this->scopeDay($query, WeekDays::saturday());
    }

    public function scopeSunday($query)
    {
        return $this->scopeDay($query, WeekDays::sunday());
    }

    /**
     * So this would require
     * @param $query
     * @return mixed
     */
    public function scopeWholeGroup($query)
    {
        if (!empty($this->outlet_id)) {
            $query->where('outlet_id', $this->outlet_id);
        }

        return $query
            ->where('restaurant_id', $this->restaurant_id)
            ->where('type_id', $this->type_id)
            ->where('weekday_id', $this->weekday_id);
        //            ->where('id', '<>', $this->id);
    }

    public function toTimeCluster(): Collection
    {
        $cluster = collect([]);
        $current = $this->from_date;
        $toDate = $this->to_date;
        while ($current <= $toDate) {
            $cluster->push($current);
            $current = $current->to();
        }

        return $cluster;
    }

    public function manageToggle(ExtendedDateTime $time)
    {
        $others = $this->wholeGroup()->get();
        $includes = $others->filterByTime($time);
        if ($includes->isNotEmpty()) {
            $this->exclude($time);
        } else {
            $this->include($time);
        }
        return $this;
    }



    public function slots()
    {
        return $this->belongsToMany(Slots::class, 'schedule_slots_pivot', 'schedule_id', 'slot_id')
            ->withTimestamps();
    }
}
